{
  "version": 3,
  "sources": ["../src/index.ts", "../src/parse.ts", "../src/runtimeHelpers.ts", "../src/transforms/transformElement.ts", "../src/transforms/transformExpression.ts", "../src/transforms/transformText.ts", "../src/transform.ts"],
  "sourcesContent": ["import { parse } from \"./parse\";\nimport { transform } from \"./transform\";\n\nexport function compile(template) {\n  const ast = parse(template);\n  // \u751F\u6210\u4EE3\u7801\u524D\u7684\u8F6C\u5316\n  transform(ast);\n  return ast;\n}\n", "import { NodeTypes } from \"./ast\";\n\nexport function parse(template) {\n  // 1.\u521B\u5EFA\u89E3\u6790\u4E0A\u4E0B\u6587  (\u89E3\u6790\u7684\u4F4D\u7F6E\u884C\u5217\u7B49\u4FE1\u606F)\n  const context = createParserContext(template);\n\n  // \u5305\u88F9\u4E00\u4E2AFragment\n  const start = getCursor(context);\n\n  return createRoot(parseChildren(context), getSelection(context, start));\n}\nfunction createRoot(children, loc) {\n  return {\n    type: NodeTypes.ROOT, // Fragment\n    children,\n    loc,\n  };\n}\nfunction parseChildren(context) {\n  const nodes = []; // \u4FDD\u5B58\u89E3\u6790\u51FA\u6765\u7684\u8282\u70B9\n  /**\n   * < \u5143\u7D20\n   * {{}} \u8868\u8FBE\u5F0F\n   */\n  while (!isEnd(context)) {\n    const { source } = context;\n    let node;\n    if (source.startsWith(\"{{\")) {\n      node = parseInterpolation(context);\n    } else if (source[0] === \"<\") {\n      node = parseElement(context);\n    }\n    // \u6587\u672C\n    if (!node) {\n      node = psrseText(context);\n    }\n    nodes.push(node);\n  }\n  // \u53BB\u9664\u7A7A\u767D\u8282\u70B9\n  nodes.forEach((node, i) => {\n    if (node.type === NodeTypes.TEXT) {\n      if (!/[^\\t\\r\\n ]/.test(node.content)) {\n        nodes[i] = null;\n      }\n    }\n  });\n  return nodes.filter(Boolean);\n}\nfunction isEnd(context) {\n  const { source } = context;\n  if (source.startsWith(\"</\")) {\n    return true;\n  }\n  return source.length === 0;\n}\n\nfunction getSelection(context, start, end?) {\n  end = end || getCursor(context);\n  return {\n    start,\n    end,\n    source: context.originalSource.slice(start.offset, end.offset),\n  };\n}\nfunction parseElement(context) {\n  // <br />  <div name=\"cjl\"></div>\n  let ele = parseTag(context); // \u5F97\u5230\u89E3\u6790\u7684\u5143\u7D20 \u4F8B\u5982div\n  let children = parseChildren(context);\n\n  if (context.source.startsWith(\"</\")) {\n    // \u8BF4\u660E\u6807\u7B7E\u4E2D\u95F4\u6CA1\u6709\u5185\u5BB9\n    parseTag(context);\n  }\n  ele.loc = getSelection(context, ele.loc.start);\n  ele.children = children;\n  return ele;\n}\nfunction parseTag(context) {\n  const start = getCursor(context);\n  const match = /^<\\/?([a-z][^ \\t\\r\\n/>]*)/.exec(context.source);\n  const tag = match[1]; // \u62FF\u5230\u6807\u7B7E\u540D\n\n  advanceBy(context, match[0].length); // \u5220\u6389\u6807\u7B7E <div\n  advanceBySpaces(context); // \u5220\u9664\u7A7A\u683C\n\n  //  \u89E3\u6790\u5C5E\u6027\n  const props = parseAttributes(context);\n  // <div>   <div/>\n  // \u5224\u65AD\u662F\u5426\u4E3A\u81EA\u95ED\u548C\u6807\u7B7E\n  const isSelfClosing = context.source.startsWith(\"/>\");\n\n  advanceBy(context, isSelfClosing ? 2 : 1);\n\n  return {\n    type: NodeTypes.ELEMENT,\n    tag,\n    isSelfClosing,\n    children: [],\n    props,\n    loc: getSelection(context, start),\n  };\n}\nfunction parseAttributes(context) {\n  const props = [];\n  while (context.source.length > 0 && !context.source.startsWith(\">\")) {\n    const prop = parseAttribute(context);\n    props.push(prop);\n    advanceBySpaces(context); // \u5220\u9664\u7A7A\u683C\n  }\n  return props;\n}\nfunction parseAttribute(context) {\n  const start = getCursor(context);\n\n  // \u89E3\u6790\u5C5E\u6027\u540D\u5B57\n  const match = /^[^\\t\\r\\n\\f />][^\\t\\r\\n\\f />=]*/.exec(context.source);\n\n  let name = match[0];\n\n  advanceBy(context, name.length);\n\n  advanceBySpaces(context); // a =\"1\" \u5220\u6389\u7A7A\u683C\n\n  advanceBy(context, 1); // \u5220\u6389 =\n\n  const value = parseAttributeValue(context);\n\n  return {\n    type: NodeTypes.ATTRIBUTE,\n    name,\n    value: {\n      type: NodeTypes.TEXT,\n      content: value.content,\n      loc: value.loc,\n    },\n    loc: getSelection(context, start),\n  };\n}\nfunction parseAttributeValue(context) {\n  const start = getCursor(context);\n  // '' \"\"\n  const quote = context.source[0];\n  let content;\n  if (quote == '\"' || quote == \"'\") {\n    advanceBy(context, 1);\n    const endIndex = context.source.indexOf(quote);\n    content = parseTextData(context, endIndex);\n    advanceBy(context, 1);\n  }\n  return {\n    content,\n    loc: getSelection(context, start),\n  };\n}\nfunction parseInterpolation(context) {\n  const start = getCursor(context);\n  const closeIndex = context.source.indexOf(\"}}\", \"{{\".length);\n  advanceBy(context, 2);\n  const innerStart = getCursor(context);\n  const innerEnd = getCursor(context);\n  // \u62FF\u5230\u53CC\u5927\u62EC\u53F7\u91CC\u7684\u5185\u5BB9\n  const rawContentLength = closeIndex - 2;\n\n  const preContent = parseTextData(context, rawContentLength);\n\n  const content = preContent.trim();\n\n  const startOffset = preContent.indexOf(content);\n\n  if (startOffset > 0) {\n    // \u66F4\u65B0start\n    advancePositionWithMutation(innerStart, preContent, startOffset);\n  }\n  // \u66F4\u65B0\u7ED3\u5C3E\n  const endOffset = startOffset + content.length;\n\n  advancePositionWithMutation(innerEnd, preContent, endOffset);\n  advanceBy(context, 2);\n  return {\n    type: NodeTypes.INTERPOLATION,\n    content: {\n      type: NodeTypes.SIMPLE_EXPRESSION,\n      content,\n      loc: getSelection(context, innerStart, innerEnd),\n    },\n    loc: getSelection(context, start),\n  };\n}\nfunction psrseText(context) {\n  const endTokens = [\"<\", \"{{\"]; // \u6587\u672C\u7ED3\u675F\u7684\u6807\u8BC6\n  let endIndex = context.source.length; // \u9ED8\u8BA4\u8BA4\u4E3A\u6587\u672C\u5C31\u662F\u6574\u4E2Asource\n  for (let i = 0; i < endTokens.length; i++) {\n    const index = context.source.indexOf(endTokens[i], 1);\n    if (index !== -1) {\n      endIndex = Math.min(endIndex, index);\n    }\n  }\n\n  // \u521B\u5EFA\u884C\u5217\u4FE1\u606F \u6709\u5229\u4E8E\u540E\u671F\u8FFD\u8E2A\n  const start = getCursor(context);\n\n  // \u62FF\u5230\u5185\u5BB9\n  const content = parseTextData(context, endIndex);\n  return {\n    type: NodeTypes.TEXT, // \u7C7B\u578B\n    content, // \u5185\u5BB9\n    loc: getSelection(context, start),\n  };\n}\nfunction advanceBy(context, endIndex) {\n  const source = context.source;\n  // \u66F4\u65B0\u884C\u5217\u4FE1\u606F\n  advancePositionWithMutation(context, source, endIndex);\n  context.source = source.slice(endIndex);\n}\nfunction advanceBySpaces(context) {\n  const match = /^[ \\t\\r\\n]+/.exec(context.source);\n\n  if (match) {\n    advanceBy(context, match[0].length);\n  }\n}\nfunction advancePositionWithMutation(context, source, endIndex) {\n  let linesCount = 0;\n  let linPos = -1;\n  for (let i = 0; i < endIndex; i++) {\n    // \u6362\u884C\n    if (source.charCodeAt(i) === 10) {\n      linesCount++;\n      linPos = i;\n    }\n  }\n  context.line += linesCount;\n  context.offset += endIndex;\n  context.column = linPos == -1 ? context.column + endIndex : endIndex - linPos;\n}\nfunction parseTextData(context, endIndex) {\n  const rawText = context.source.slice(0, endIndex);\n  // \u5220\u6389\u5DF2\u7ECF\u89E3\u6790\u7684\u5185\u5BB9\n  advanceBy(context, endIndex);\n  return rawText;\n}\nfunction getCursor(context) {\n  const { line, column, offset } = context;\n  return {\n    line,\n    column,\n    offset,\n  };\n}\nfunction createParserContext(template) {\n  return {\n    line: 1,\n    column: 1,\n    offset: 0,\n    source: template, // \u76EE\u524D\u5269\u4E0B\u7684template\uFF08\u4F1A\u4E0D\u505C\u88AB\u622A\u53D6\uFF09\n    originalSource: template, // \u4E0D\u4F1A\u53D8\n  };\n}\n", "export const TO_DISPLAY_STRING = Symbol(\"toDisplayString\");\n\nexport const helperMap = {\n  [TO_DISPLAY_STRING]: \"toDisplayString\",\n};\n", "import { NodeTypes } from \"../ast\";\nfunction isText(node) {\n  return node.type === NodeTypes.TEXT || node.type === NodeTypes.INTERPOLATION;\n}\nexport function transformElement(node, context) {\n  if (node.type === NodeTypes.ELEMENT) {\n    return () => {\n      const children = node.children;\n      let hasText;\n      // \u5408\u5E76\u8FDE\u7EED\u7684\u8868\u8FBE\u5F0F\u548C\u6587\u672C  \u4F8B\u5982 {{aaa}}  \u54C8\u54C8\u54C8\n      let currentContainer = null;\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        if (isText(child)) {\n          hasText = true;\n          // \u4E0B\u4E00\u8282\u70B9\u662F\u5426\u4E3A\u6587\u672C\u8282\u70B9\n          for (let j = i + 1; j < children.length; j++) {\n            const next = children[j];\n            if (isText(next)) {\n              if (!currentContainer) {\n                currentContainer = children[i] = {\n                  type: NodeTypes.COMPOUND_EXPRESSION,\n                  children: [child],\n                };\n              }\n              currentContainer.children.push(` + `, next);\n              children.splice(j, 1);\n              j--;\n            } else {\n              currentContainer = null;\n              break;\n            }\n          }\n        }\n      }\n      if (!hasText || children.length === 1) {\n        return;\n      }\n\n      console.log(node);\n    };\n  }\n}\n", "import { NodeTypes } from \"../ast\";\n\nexport function transformExpression(node, context) {\n  // \u8868\u8FBE\u5F0F\u7684\u5185\u5BB9\u653E\u5230\u4E86node.content.content\u91CC\u9762\n  if (node.type === NodeTypes.INTERPOLATION) {\n    const content = node.content.content;\n    node.content.content = `_ctx.${content}`;\n  }\n}\n", "import { NodeTypes } from \"../ast\";\nfunction isText(node) {\n  return node.type === NodeTypes.TEXT || node.type === NodeTypes.INTERPOLATION;\n}\nexport function transformText(node, context) {\n  if (node.type === NodeTypes.ELEMENT || node.type === NodeTypes.TEXT) {\n    return () => {};\n  }\n}\n", "import { NodeTypes } from \"./ast\";\nimport { TO_DISPLAY_STRING } from \"./runtimeHelpers\";\nimport { transformElement } from \"./transforms/transformElement\";\nimport { transformExpression } from \"./transforms/transformExpression\";\nimport { transformText } from \"./transforms/transformText\";\n\nexport function transform(ast) {\n  const context = createTransformContext(ast);\n  traverse(ast, context);\n}\n\nfunction traverse(node, context) {\n  context.currentNode = node;\n  const transforms = context.nodeTransforms;\n  const exitFns = [];\n  for (let i = 0; i < transforms.length; i++) {\n    const onExit = transforms[i](node, context);\n    onExit && exitFns.push(onExit);\n    if (!context.currentNode) return; // \u5982\u679C\u5F53\u524D\u8282\u70B9\u88AB\u5220\u6389\u4E86\uFF0C\u5C31\u4E0D\u9700\u8981\u904D\u5386\u513F\u5B50\u4E86\n  }\n\n  switch (node.type) {\n    case NodeTypes.INTERPOLATION:\n      context.helper(TO_DISPLAY_STRING);\n      break;\n    case NodeTypes.ELEMENT:\n    case NodeTypes.ROOT:\n      for (let i = 0; i < node.children.length; i++) {\n        context.parent = node;\n        traverse(node.children[i], context);\n      }\n      break;\n    default:\n      break;\n  }\n  context.currentNode = node;\n  let i = exitFns.length;\n  while (i--) {\n    exitFns[i]();\n  }\n}\n\nfunction createTransformContext(root) {\n  const context = {\n    currentNode: root, // \u5F53\u524D\u8282\u70B9\n    parent: null, // \u7236\u8282\u70B9\n    helpers: new Map(),\n    helper(name) {\n      const count = context.helpers.get(name) || 0;\n      context.helpers.set(name, count + 1);\n      return name;\n    },\n    nodeTransforms: [transformElement, transformText, transformExpression],\n  };\n  return context;\n}\n"],
  "mappings": "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",
  "names": ["i"]
}
